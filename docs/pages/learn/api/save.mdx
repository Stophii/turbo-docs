# Save and Load

## Overview

`Save` allows for in-game data to persist between session, this can extremely useful for web gaming session. `Load` will allow this data to be retrieved either automatically or manually.

## API

### `local::save()`

Saves your game by converting data into a `borsh::vec`.

```rust
local::save(data: &[u8]) -> Result<i32, i32>
```

### `local::load()`

Loads your game by reading the `borsh::vec` created by `local::save`.

```rust
local::load() Result<Vec<u8>, i32> 
```

## Usage

### Saving

```rust
pub fn save_local(&self) {
    let data = borsh::to_vec(self);
    if let Ok(d) = data {
        let _ = local::save(&d);
    } else {
        log!("error saving");
    }
}
```

Call this function whenever you require a save.

```rust
self.save_local();
```

### Loading

```rust
pub fn load_local() -> GameState {
    let data = local::load().unwrap_or_else(|_| vec![]);
    match borsh::from_slice(&data) {
        Ok(state) => return state,
        Err(_) => {
            log!("error loading game state");
            return GameState::create();
        }
    }
}
```

Call this function whenever you require a load

```rust
*self = GameState::load_local();
```

### Autoloading On Boot

When booting up your game if data exists it will be loaded, if not it will create a new save.

```rust
use turbo::*;

#[turbo::game]
struct GameState {
    // Add fields here
}
impl GameState {

    pub fn new() -> Self { 
        // initialize your game state 
        GameState::load_local() 
    }

    pub fn create() -> Self { 
        Self { 
        } 
    } 

    pub fn update(&mut self) {
        // This is where your main game loop code goes
        // The stuff in this block will run ~60x per sec
        text!("Hello, world!!!");
    }
}
```

### Delete Saved Data

Wipe the `GameState` returning it back to its defaulted values.

```rust
*self = GameState::create();
```

Save after doing this to wipe your previous data.
