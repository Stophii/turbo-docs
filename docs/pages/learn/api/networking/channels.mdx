# Channels

![Two ghosts sharing a computer](/ghosts_at_computer.png)

## Overview

The client-side `channel` API lets your game subscribe to a Turbo OS channel, send and receive incoming messages asynchronously. Channels are good for fast-paced multiplayer gameplay.

## Creating a Channel

To create a channel, you must first create structs or enums that your channel will receive and send.

To demonstrate, let's make a "ping pong" channel that accepts "ping" messages and sends back "pong" messages in response:

```rs
// We will send this one to the channel
#[turbo::serialize]
pub struct Ping;

// We will get this one back from the channel
#[turbo::serialize]
pub struct Pong;
```

Next, we have to implement the `ChannelHandler` trait:

```rs
#[turbo::os::channel(program = "pingpong", name = "main")]
pub struct PingPongChannel;
impl ChannelHandler for PingPongChannel {
    type Recv = Ping; // incoming from client
    type Send = Pong; // outgoing to client
    fn new() -> Self {
        Self
    }
    fn on_data(&mut self, user_id: &str, data: Self::Recv) -> Result<(), std::io::Error> {
        log!("Got {:?} from {:?}", data, user_id);
        Self::send(user_id, Pong)
    }
}
```

Here, we use the `turbo::os::channel` macro to tag our ChannelHandler with program and channel names. The macro will ensure our program is uploaded and will add an additional `subscribe` method to `PingPongChannel` which will be useful when interacting with the channel on the client side.

## Connecting to a Channel

Last, we can hook up the client:

```rs
use turbo::*;

#[turbo::game]
struct GameState;
impl GameState {
    fn update(&mut self) {
        // Subscribe to the "ping pong" channel to get a `ChannelConnection`
        if let Some(mut conn) = PingPongChannel::subscribe("default") {
            // Pull Pong messages using the `ChannelConnection::recv` method
            while let Ok(msg) = conn.recv() {
                log!("Received pong from server!");
            }
            if gamepad::get(0).start.just_pressed() {
                // Send a Ping message using the `ChannelConnection::send` method
                let _ = conn.send(&Ping);
                log!("Sent ping to the server!");
            }
        }
    }
}
```

```rs
use turbo::*;

#[turbo::game]
struct GameState;
impl GameState {
    fn update(&mut self) {
        // Subscribe to the "ping pong" channel to get a `ChannelConnection` // [!code focus] [!code hl]
        if let Some(mut conn) = PingPongChannel::subscribe("default") { // [!code focus] [!code hl]
            // The ChannelConnection (`conn`) is within scope, // [!code focus] [!code hl]
            // It may be used to receive and send messages from the channel // [!code focus] [!code hl]
        } // [!code focus] [!code hl]
    }
}
```

## Running your game

Update your `turbo.toml` file to include the following section:

```toml
[turbo-os]
api-url = "https://os.turbo.computer"
```

Next, create a free dev account at https://os.turbo.computer. The dashboard will have your user ID.

```sh
turbo run -w --user <YOUR_USER_ID>
```

It will prompt for a one-time password you can also find on your Turbo OS dashboard.

Once your game window opens, it will upload your program:

```sh
[turbo] Uploading "pingpong" (YOUR_PROGRAM_ID)...
[turbo] Uploaded "pingpong" (YOUR_PROGRAM_ID) âœ¨
```

When connects to the channel, you will see some output like the following:

```sh
[turbo] Channel connection open:
- program      : YOUR_PROGRAM_ID
- channel name : main
- channel id   : default
- inspector url: https://os.turbo.computer/channels/YOUR_PROGRAM_ID/main/default/inspector
```

If you press the start button on a gamepad or space on a keyboard, you will see the following output on the command line:

```sh
[turbo] Sent ping to the server!
[turbo] Received pong from server!
```

You can visit that "inspector url" to view the channel inspector page. There, you can observe messages sent to/from the server, user connection/disconnection events, and logs:

![Channel inspector screenshot](/pingpong-inspector.png)
