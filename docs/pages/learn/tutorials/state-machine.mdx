# State Machine [A crucial skill and it's so easy to learn]

## Overview

:::info[Summary]

> In this tutorial you'll learn the basics of making a state machine which will allow you to start building a modular base of operations for any video game idea! 

**Difficulty**

> ★☆☆☆☆

**Time Estimate**

> ~10 minutes

**What You'll Learn**

- [x] How to initialize and run a Turbo project
- [x] How to make new files and utilize them
- [x] How to add in custom functions + enumerations
- [x] How to flip between a title, loading, and game screen

:::

## Walkthrough

:::tip[Development Tip]
The full source code of this game is [available on Github](https://github.com/Stophii/State-Machine) and a video guide is [available on Youtube](https://www.youtube.com/watch?v=0LuQa6T_pKQ&t=2s)

:::

::::steps

### Initialize the Project

Begin by creating a new project called `state-machine`

```bash [Terminal]
turbo init state-machine
```

This initializes a Rust project with the following structure:

```
state-machine/          # Your project's root directory.
├── src/                # The directory of your code. <!-- [!code focus] [!code hl] -->
│   └── lib.rs          # The main file for the game. <!-- [!code focus] [!code hl] -->
├── Cargo.toml          # Rust project manifest. <!-- [!code focus] [!code hl] -->
└── turbo.toml          # Turbo configuration. <!-- [!code focus] [!code hl] -->
```

### Create a `state.rs` File

Inside your project directory, create a file named `state`. This file will contain your state machine.

```
your-project-dir/       # Your project's root directory.
├── src/                # The directory of your code.
│   └── lib.rs          # The main file for the game.
|   └── state.rs        # The secondary file we created. <!-- [!code focus] [!code hl] [!code ++] -->
├── Cargo.toml          # Rust project manifest.
└── turbo.toml          # Turbo configuration.
```

### Enabling another File 

Add the following lines of code to the top of each file.

- [x] lib.rs
```rs [src/lib.rs]
use turbo::*;

use state::*; // [!code ++] [!code focus] [!code hl]
mod state;    // [!code ++] [!code focus] [!code hl]

```
- [x] state.rs
```rs [src/state.rs]
use crate::*; // [!code ++] [!code focus] [!code hl]


```

This will make the code we write in `state` to be recognized inside of `lib.rs` and vice versa.

### Run the Game

At this point, we can run our game and leave it running as we make changes. Don't worry, it is just a blank screen for now!

```bash [Terminal]
turbo run -w state-machine
```

:::tip[Development Tip]
If you want it to always appear above your other open windows you can run it with
```bash [Terminal]
turbo run -w -A state-machine
```
The `-A` will make it "always on top".
:::


### Game State Initialization & `state.rs` setup

Add this code to your `state.rs` file. This is an enum we'll use for switching screens:

```rs [src/state.rs]
use crate::*;

#[turbo::serialize] // add this above structs and enums // [!code ++] [!code focus] [!code hl]
pub enum Screen { // [!code ++] [!code focus] [!code hl]
    Title, // [!code ++] [!code focus] [!code hl]
    Loading, // [!code ++] [!code focus] [!code hl]
    Game, // [!code ++] [!code focus] [!code hl]
} // [!code ++] [!code focus] [!code hl]
```

Now we can head into `lib.rs` and add the following fields to `GameState`

```rs [src/lib.rs]
struct GameState {
    screen: Screen, // [!code ++] [!code focus] [!code hl]
    frames: u32, // [!code ++] [!code focus] [!code hl]
}

impl GameState {
    pub fn new() -> Self {
        // initialize your game state
        Self { 
            screen: Screen::Title, // [!code ++] [!code focus] [!code hl]
            frames: 0,  // [!code ++] [!code focus] [!code hl]
        }
    }
    pub fn update(&mut self) {
        // This is where your main game loop code goes
        // The stuff in this block will run ~60x per sec
    }
}
```

### Adding in the State Machine

Now we'll add in an empty state machine.

```rs [src/state.rs]
use crate::*;

#[turbo::serialize] // add this above structs and enums 
pub enum Screen { 
    Title, 
    Loading, 
    Game, 
} 

pub fn state_of_game(state: &mut GameState) { // [!code ++] [!code focus] [!code hl]
    match state.screen { // [!code ++] [!code focus] [!code hl]
        Screen::Title => { // [!code ++] [!code focus] [!code hl]
// [!code ++] [!code focus] [!code hl]
        } // [!code ++] [!code focus] [!code hl]
        Screen::Loading => { // [!code ++] [!code focus] [!code hl]
// [!code ++] [!code focus] [!code hl]
        } // [!code ++] [!code focus] [!code hl]
        Screen::Game => { // [!code ++] [!code focus] [!code hl]
// [!code ++] [!code focus] [!code hl]
        } // [!code ++] [!code focus] [!code hl]
    } // [!code ++] [!code focus] [!code hl]
} // [!code ++] [!code focus] [!code hl]
```

:::tip[Development Tip]
Saving your project is done with Cmd+S (MacOS) or Ctrl+S (Windows).
Reloading your project is done with Cmd+R (MacOS) or Ctrl+R (Windows).
:::

### Adding our function to the `update` 

Now in order to view and interact with our state machine we need to call it in the `GameState::update`

```rs [src/lib.rs]
pub fn update(&mut self) {
    state_of_game(self); // [!code ++] [!code focus] [!code hl]
    // This is where your main game loop code goes
    // The stuff in this block will run ~60x per sec
}
```
:::tip[Development Tip]
`update()` runs 60 times per second, and is repsonsible for updating all changes to your game state.
:::

### Personalize your State Machine

Now you'll need to add some substance to your `state_of_game` function so you can see it display.

:::warning[Quest]
Try making your own UI! Have it include the following:

- [x] A way to change from each `screen`
- [x] An indicator for each `screen` so the user can know what screen they're on
- [x] Automate the `Screen::Loading` to change without input 
- [x] Use state.frames

Post your UI to the turbo discord in the #general channel to recieve the following rewards:
`100`exp
:::

Here is an example UI following the quest template!

```rs [src/state.rs]
pub fn state_of_game(state: &mut GameState) {
    match state.screen {
        Screen::Title => {
            text!("Title Screen!", x = 100, y = 60); // [!code ++] [!code focus] [!code hl]
            text!("Press z to begin!", x = 100, y = 90); // [!code ++] [!code focus] [!code hl]
            if gamepad::get(0).a.just_pressed() { // [!code ++] [!code focus] [!code hl]
                state.screen = Screen::Loading // [!code ++] [!code focus] [!code hl]
            } // [!code ++] [!code focus] [!code hl]
        }
        Screen::Loading => {
            if state.frames >= 150 { // [!code ++] [!code focus] [!code hl]
                text!("Loading...", x = 100, y = 90); // [!code ++] [!code focus] [!code hl]
            } else if state.frames >= 75 { // [!code ++] [!code focus] [!code hl]
                text!("Loading..", x = 100, y = 90); // [!code ++] [!code focus] [!code hl]
            } else { // [!code ++] [!code focus] [!code hl]
                text!("Loading.", x = 100, y = 90); // [!code ++] [!code focus] [!code hl]
            } // [!code ++] [!code focus] [!code hl]
            state.frames += 1; // [!code ++] [!code focus] [!code hl]
            if state.frames >= 200 { // [!code ++] [!code focus] [!code hl]
                state.screen = Screen::Game; // [!code ++] [!code focus] [!code hl]
                state.frames = 0; // [!code ++] [!code focus] [!code hl]
            } // [!code ++] [!code focus] [!code hl]
        }
        Screen::Game => {
            text!("Hello, world!!!", x = 100, y = 60); // [!code ++] [!code focus] [!code hl]
            if gamepad::get(0).b.just_pressed() { // [!code ++] [!code focus] [!code hl]
                state.screen = Screen::Title // [!code ++] [!code focus] [!code hl]
            } // [!code ++] [!code focus] [!code hl] 
        }
    }
}

As you make changes to the `state_of_game` 
```
:::tip[Development Tip]
If you are doing the quest as you make changes to the `state_of_game` make sure to save with Cmd+S or Ctrl+S so you can view your changes in real time!
:::

## Conclusion

Awesome you just made a working State machine which will help you stay organized and set your project up for becoming easily expandable!

You can make title screens, automate loading screens, and display the game screen. You’ve learned a crucial skill towards making games fast, what's next!?

## Next Steps

- Add a GameOver `enum` and make a game over screen
- Explore [different options](/learn/api/pointer) of changing the `state.screen`
- Complete the `Quest` above
- Try your hand at the [pancake cat tutorial](/learn/tutorials/pancake-cat)
